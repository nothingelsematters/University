## [Необходимо создать игрушечный интерпретатор](https://github.com/nothingelsematters/terminal.git)

### Цель - получить представление о том, как работают командные интерпретаторы.

Программа должна в бесконечном цикле считывать с stdin полный путь к
исполняемому файлу, который необходимо запустить и аргументы запуска.
Дождавшись завершения процесса необходимо вывести на stdout код его завершения.

Необходимо использовать прямые системные вызовы для порождения новых процессов,
запуска новых исполняемых файлов и получения статуса завершения системного
вызова.

Все возвращаемые значения системных вызовов должны быть проверены и в случае
обнаружения ошибок необходимо выводить текстовое описание ошибки.

На входе могут быть некорректные данные.

Дополнительные баллы - поддержка переменных окружения.

Язык имплементации - C или C++.

---

## [Необходимо написать подмножество утилиты find](https://github.com/nothingelsematters/find.git)

## Программа должна:

- Первым аргументом принимать абсолютный путь, в котором будет производиться поиск файлов.
- По-умолчанию выводить в стандартный поток вывода все найденные файлы по этому пути
- Поддерживать аргумент -inum num. Аргумент задает номер инода
- Поддерживать аргумент -name name. Аргумент задает имя файла
- Поддерживать аргумент -size [-=+]size. Аргумент задает фильтр файлов по размеру(меньше, равен, больше)
- Поддерживать аргумент -nlinks num. Аргумент задает количество hardlink'ов у файлов
- Поддерживать аргумент -exec path. Аргумент задает путь до исполняемого файла, которому в качестве единственного аргумент нужно передать найденный в иерархии файл
- Поддерживать комбинацию аргументов. Например хочется найти все файлы с размером больше 1GB и скормить их утилите /usr/bin/sha1sum.
- Выполнять поиск рекурсивно, в том числе во всех вложенных директориях.
- Сильные духом призываются к выполнению задания с использованием системного вызова getdents(2). Остальные могут использовать readdir и opendir для чтения содержимого директории.

---

#  [Кусочек JIT компилятора](https://github.com/nothingelsematters/pseudo-jit.git)

Цель - получить знакомство с системными вызывами, используемыми для получения/освобождения
памяти от ядра. Получить представление о том, как может работать JIT компилятор.

## Программа должна
 * Выделить память с помощью mmap(2).
 * Записать в выделенную память машинный код, соответсвующий какой-либо функции.
 * Изменить права на выделенную память - чтение и исполнение. See: mprotect(2).
 * Вызвать функцию по указателю на выделенную память.
 * Освободить выделенную память.

## Что может помочь?
 * man objdump
 * help disassemble в gdb

## Extra points
Сильные духом призываются к возможности модификации кода выполняемой функции
в runtime. Например, вы можете получить аргументом вызова вашей программы
какое-то число и пропатчить машинный код этим числом. Эта часть задания будет
оцениваться в дополнительные баллы.
