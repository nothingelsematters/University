## [Необходимо создать игрушечный интерпретатор](https://github.com/nothingelsematters/terminal.git)

### Цель - получить представление о том, как работают командные интерпретаторы.

Программа должна в бесконечном цикле считывать с stdin полный путь к
исполняемому файлу, который необходимо запустить и аргументы запуска.
Дождавшись завершения процесса необходимо вывести на stdout код его завершения.

Необходимо использовать прямые системные вызовы для порождения новых процессов,
запуска новых исполняемых файлов и получения статуса завершения системного
вызова.

Все возвращаемые значения системных вызовов должны быть проверены и в случае
обнаружения ошибок необходимо выводить текстовое описание ошибки.

На входе могут быть некорректные данные.

Дополнительные баллы - поддержка переменных окружения.

Язык имплементации - C или C++.

---

## [Необходимо написать подмножество утилиты find](https://github.com/nothingelsematters/find.git)

## Программа должна:

- Первым аргументом принимать абсолютный путь, в котором будет производиться поиск файлов.
- По-умолчанию выводить в стандартный поток вывода все найденные файлы по этому пути
- Поддерживать аргумент -inum num. Аргумент задает номер инода
- Поддерживать аргумент -name name. Аргумент задает имя файла
- Поддерживать аргумент -size [-=+]size. Аргумент задает фильтр файлов по размеру(меньше, равен, больше)
- Поддерживать аргумент -nlinks num. Аргумент задает количество hardlink'ов у файлов
- Поддерживать аргумент -exec path. Аргумент задает путь до исполняемого файла, которому в качестве единственного аргумент нужно передать найденный в иерархии файл
- Поддерживать комбинацию аргументов. Например хочется найти все файлы с размером больше 1GB и скормить их утилите /usr/bin/sha1sum.
- Выполнять поиск рекурсивно, в том числе во всех вложенных директориях.
- Сильные духом призываются к выполнению задания с использованием системного вызова getdents(2). Остальные могут использовать readdir и opendir для чтения содержимого директории.

---

##  [Кусочек JIT компилятора](https://github.com/nothingelsematters/pseudo-jit.git)

Цель - получить знакомство с системными вызывами, используемыми для получения/освобождения
памяти от ядра. Получить представление о том, как может работать JIT компилятор.

## Программа должна
 * Выделить память с помощью mmap(2).
 * Записать в выделенную память машинный код, соответсвующий какой-либо функции.
 * Изменить права на выделенную память - чтение и исполнение. See: mprotect(2).
 * Вызвать функцию по указателю на выделенную память.
 * Освободить выделенную память.

## Что может помочь?
 * man objdump
 * help disassemble в gdb

## Extra points
Сильные духом призываются к возможности модификации кода выполняемой функции
в runtime. Например, вы можете получить аргументом вызова вашей программы
какое-то число и пропатчить машинный код этим числом. Эта часть задания будет
оцениваться в дополнительные баллы.

---

##  [Знакомство с библиотеками](https://github.com/nothingelsematters/libs-acquaintance.git)

Необходимо создать статическую, и две динамических библиотеки и программу, которая будет их использовать.
Помимо этого нужен Makefile(либо другой инструмент автоматизации сборки), с помощью которого можно будет собрать все части.

## Статическая библиотека должна:
 * Собираться статически
 * Предоставлять какие-то функции<

## Первая динамическая библиотека должна:
 * Собираться динамически
 * Динамически линковаться с программой на этапе линковки
 * Предоставлять какие-то функции

## Вторая динамическая библиотека должна:
 * Собираться динамически
 * Предоставлять какие-то функции

## Программа должна
 * Статически линковаться с статической библиотекой и вызывать предоставляемые ей функции
 * Динамически линковаться с первой динамической библиотекой и вызывать предоставляемые ей функции
 * Во время выполнения в явном виде загружать вторую динамическию библиотеку с помощью dlopen(3) и вызывать какие-то функции из нее

# Что может помочь при выполнении задания?
 * man dlopen(3), man ld(1), man gcc(1)
