# Operation Systems

1. [Игрушечный интерпретатор](#Interpretator)
2. [Подмножество find](#Find)
3. [Кусочек JIT компилятора](#JIT)
4. [Знакомство с библиотеками](#Libs)
5. [Знакомство с сокетами](#Sockets)

***

<a name="Interpretator"></a>
## [Необходимо создать игрушечный интерпретатор](https://github.com/nothingelsematters/terminal.git)

### Цель - получить представление о том, как работают командные интерпретаторы.

Программа должна в бесконечном цикле считывать с stdin полный путь к
исполняемому файлу, который необходимо запустить и аргументы запуска.
Дождавшись завершения процесса необходимо вывести на stdout код его завершения.

Необходимо использовать прямые системные вызовы для порождения новых процессов,
запуска новых исполняемых файлов и получения статуса завершения системного
вызова.

Все возвращаемые значения системных вызовов должны быть проверены и в случае
обнаружения ошибок необходимо выводить текстовое описание ошибки.

На входе могут быть некорректные данные.

Дополнительные баллы - поддержка переменных окружения.

Язык имплементации - C или C++.

---

<a name="Find"></a>
## [Необходимо написать подмножество утилиты find](https://github.com/nothingelsematters/find.git)

### Программа должна:

- Первым аргументом принимать абсолютный путь, в котором будет производиться поиск файлов.
- По-умолчанию выводить в стандартный поток вывода все найденные файлы по этому пути
- Поддерживать аргумент -inum num. Аргумент задает номер инода
- Поддерживать аргумент -name name. Аргумент задает имя файла
- Поддерживать аргумент -size [-=+]size. Аргумент задает фильтр файлов по размеру(меньше, равен, больше)
- Поддерживать аргумент -nlinks num. Аргумент задает количество hardlink'ов у файлов
- Поддерживать аргумент -exec path. Аргумент задает путь до исполняемого файла, которому в качестве единственного аргумент нужно передать найденный в иерархии файл
- Поддерживать комбинацию аргументов. Например хочется найти все файлы с размером больше 1GB и скормить их утилите /usr/bin/sha1sum.
- Выполнять поиск рекурсивно, в том числе во всех вложенных директориях.
- Сильные духом призываются к выполнению задания с использованием системного вызова getdents(2). Остальные могут использовать readdir и opendir для чтения содержимого директории.

---

<a name="JIT"></a>
##  [Кусочек JIT компилятора](https://github.com/nothingelsematters/pseudo-jit.git)

Цель - получить знакомство с системными вызывами, используемыми для получения/освобождения
памяти от ядра. Получить представление о том, как может работать JIT компилятор.

### Программа должна
 * Выделить память с помощью mmap(2).
 * Записать в выделенную память машинный код, соответсвующий какой-либо функции.
 * Изменить права на выделенную память - чтение и исполнение. See: mprotect(2).
 * Вызвать функцию по указателю на выделенную память.
 * Освободить выделенную память.

### Что может помочь?
 * man objdump
 * help disassemble в gdb

### Extra points
Сильные духом призываются к возможности модификации кода выполняемой функции
в runtime. Например, вы можете получить аргументом вызова вашей программы
какое-то число и пропатчить машинный код этим числом. Эта часть задания будет
оцениваться в дополнительные баллы.

---

<a name="Libs"></a>
##  [Знакомство с библиотеками](https://github.com/nothingelsematters/libs-acquaintance.git)

Необходимо создать статическую, и две динамических библиотеки и программу, которая будет их использовать.
Помимо этого нужен Makefile(либо другой инструмент автоматизации сборки), с помощью которого можно будет собрать все части.

### Статическая библиотека должна:
 * Собираться статически
 * Предоставлять какие-то функции<

### Первая динамическая библиотека должна:
 * Собираться динамически
 * Динамически линковаться с программой на этапе линковки
 * Предоставлять какие-то функции

### Вторая динамическая библиотека должна:
 * Собираться динамически
 * Предоставлять какие-то функции

### Программа должна
 * Статически линковаться с статической библиотекой и вызывать предоставляемые ей функции
 * Динамически линковаться с первой динамической библиотекой и вызывать предоставляемые ей функции
 * Во время выполнения в явном виде загружать вторую динамическию библиотеку с помощью dlopen(3) и вызывать какие-то функции из нее

### Что может помочь при выполнении задания?
 * man dlopen(3), man ld(1), man gcc(1)

---

<a name="Sockets"></a>
## [Знакомство с сокетами](https://github.com/nothingelsematters/synchronous-socket-service.git)

Необходимо попробовать клиент-серверное взаимодействие через синхронные сокеты.
Помимо этого нужен Makefile, с помощью которого можно будет собрать клиент и сервер.
Семейство протоколов для использования на выбор: AF_UNIX, AF_INET, AF_INET6.

### Сервер должен:
 * В качестве аргументов принимать адрес, на котором будет ожидать входящих соединений
 * Стартовать, делать bind(2) на заданный адрес и ожидать входящих соединений
 * При получении соединения, выполнять серверную часть придуманного вами протокола
 * После обработки принятого соединения возвращаться в режим ожидания входящих соединений

### Клиент должен:
 * Принимать параметром адрес, к которому стоит подключиться
 * Выполнять клиентскую часть придуманного вами протокола
 * Завершаться

Для сильных духом предлагается выбрать какой-то существующий протокол и имплементировать его, или его разумное подмножество.
Сильность духа будет оцениваться в два балла, при условии что выбранный протокол сложнее чем ECHO (https://tools.ietf.org/html/rfc862).
