+ A [Топологическая сортировка](#A)
+ B [Мосты](#B)
+ C [Точки сочленения](#C)
+ D [Компоненты реберной двусвязности](#D)
+ E [Компоненты вершинной двусвязности](#E)
+ F [Конденсация графа](#F)
+ G [Планирование вечеринки](#G)
+ H [Авиаперелеты](#H)
+ I [Остовное дерево](#I)

***

<a name="A"></a>
<h1 align="center">A. Топологическая сортировка</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p> 

__Условие:__  
Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.

__Входные данные:__  
В первой строке входного файла даны два натуральных числа N и M (1 ≤ N ≤ 100 000, 0 ≤ M ≤ 100 000) — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.

__Выходные данные:__  
Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.

__Пример__  
>__Входные данные__  
6 6  
1 2  
3 2  
4 2  
2 5  
6 5  
4 6
__Выходные данные__  
4 6 3 1 2 5 

***

<a name="B"></a>
<h1 align="center">B. Мосты</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Дан неориентированный граф, не обязательно связный, но не содержащий петель и кратных рёбер. Требуется найти все мосты в нём. 

__Входные данные:__  
Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000).  
Следующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается двумя натуральными числами bi, ei — номерами концов ребра (1 ≤ bi, ei ≤ n).

__Выходные данные:__  
Первая строка выходного файла должна содержать одно натуральное число b — количество мостов в заданном графе. На следующей строке выведите b целых чисел — номера рёбер, которые являются мостами, в возрастающем порядке. Рёбра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

__Пример__  
>__Входные данные__  
6 7  
1 2  
2 3  
3 4  
1 3  
4 5  
4 6  
5 6  
__Выходные данные__  
1  
3

***

<a name="C"></a>
<h1 align="center">C. Точки сочленения</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Дан неориентированный граф. Требуется найти все точки сочленения в нём.

__Входные данные:__  
Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000).   
Следующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается двумя натуральными числами bi, ei — номерами концов ребра (1 ≤ bi, ei ≤ n).

__Выходные данные:__  
Первая строка выходного файла должна содержать одно натуральное число b — количество точек сочленения в заданном графе. На следующей строке выведите b целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке. 

__Пример__  
>__Входные данные__  
6 7  
1 2  
2 3  
2 4  
2 5  
4 5  
1 3  
3 6  
__Выходные данные__  
2  
2 3  

***

<a name="D"></a>
<h1 align="center">D. Компоненты реберной двусвязности</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 64 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Компонентой реберной двусвязности графа называется подмножество вершин , такое что для любых различных u и v из этого множества существует не менее двух реберно не пересекающихся путей из u в v.  
Дан неориентированный граф. Требуется выделить компоненты реберной двусвязности в нем.

__Входные данные:__  
Первая строка входного файла содержит два натуральных числа n и m — количества вершин и ребер графа соответственно (1  ≤  n  ≤  20 000, 1  ≤  m  ≤  200 000).  

Следующие m строк содержат описание ребер по одному на строке. Ребро номер i описывается двумя натуральными числами bi, ei — номерами концов ребра (1 ≤ bi, ei ≤ n).

__Выходные данные:__  
В первой строке выходного файла выведите целое число k — количество компонент реберной двусвязности графа. Во второй строке выведите n натуральных чисел a1, a2, ..., an, не превосходящих k, где ai — номер компоненты реберной двусвязности, которой принадлежит i-я вершина.

__Пример__  
>__Входные данные__  
6 7  
1 2  
2 3  
3 1  
1 4  
4 5  
4 6  
5 6  
__Выходные данные__  
2  
1 1 1 2 2 2

***

<a name="E"></a>
<h1 align="center">E. Компоненты вершинной двусвязности</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 64 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>


__Условие:__  
Компонентой вершинной двусвязности графа называется максимальный по включению подграф (состоящий из вершин и ребер), такой что любые два ребра из него лежат на вершинно простом цикле.

Дан неориентированный граф без петель. Требуется выделить компоненты вершинной двусвязности в нем.

__Входные данные:__  
Первая строка входного файла содержит два натуральных числа n и m — количества вершин и ребер графа соответственно (1 ≤ n ≤ 20 000, 1 ≤ m ≤ 200 000).

Следующие m строк содержат описание ребер по одному на строке. Ребро номер i описывается двумя натуральными числами bi, ei — номерами концов ребра (1 ≤ bi, ei ≤ n).

__Выходные данные:__  
В первой строке выходного файла выведите целое число k — количество компонент вершинной двусвязности графа. Во второй строке выведите m натуральных чисел a1, a2, ..., am, не превосходящих k, где ai — номер компоненты вершинной двусвязности, которой принадлежит i-е ребро. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

__Пример__  
>__Входные данные__  
5 6  
1 2  
2 3  
3 1  
1 4  
4 5  
5 1  
__Выходные данные__  
2  
1 1 1 2 2 2 

***

<a name="F"></a>
<h1 align="center">F. Конденсация графа</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Требуется найти количество ребер в конденсации ориентированного графа. Примечание: конденсация графа не содержит кратных ребер.

__Входные данные:__  
Первая строка входного файла содержит два натуральных числа n и m — количество вершин и ребер графа соответственно (n ≤ 10 000,  m ≤ 100 000). Следующие m строк содержат описание ребер, по одному на строке. Ребро номер i описывается двумя натуральными числами bi, ei — началом и концом ребра соответственно (1  ≤  bi,  ei  ≤  n). В графе могут присутствовать кратные ребра и петли.

__Выходные данные:__  
Единственная строка выходного файла должна содержать одно число — количество ребер в конденсации графа.

__Пример__  
>__Входные данные__  
4 4  
2 1  
3 2  
2 3  
4 3  
__Выходные данные__  
2

***

<a name="G"></a>
<h1 align="center">G. Планирование вечеринки </h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 512 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Петя планирует вечеринку, это дело непростое. Одна из главных проблем в том, что некоторые его друзья плохо ладят друг с другом, а некоторые — наоборот. В результате у него есть множество требований, например: «Я приду только если придет Гена» или «Если там будет Марина, то меня там точно не будет».

Петя формализовал все требования в следующем виде: «[+-]name1 => [+-]name2», здесь «name1» и «name2» — имена двух друзей Пети, «+» означает, что друг придет в гости, «-» — что не придет. Например, выражение «Если Андрея не будет, то Даша не придет» записывается так: «-andrey => -dasha».

Помогите Пете составить хоть какой-нибудь список гостей, удовлетворяющий всем свойствам, или скажите, что это невозможно

__Входные данные:__  
В первой строке входного файла записаны числа n и m — число друзей Пети и число условий (1 ≤ n, m ≤ 1000). В следующих n строках записаны имена друзей. Имена друзей состоят из маленьких латинских букв и имеют длину не больше 10. В следующих m строках записаны условия.

__Выходные данные:__  
Выведите в первой строке число k — число друзей, которых нужно пригласить. В следующих k строках выведите их имена.

__Примерs__  
>__Входные данные__  
3 3  
vova  
masha  
gosha  
-vova => -masha  
-masha => +gosha  
+gosha => +vova  
__Выходные данные__  
2  
vova  
masha  

>__Входные данные__  
1 1  
vova  
-vova => +vova  
__Выходные данные__  
1  
vova 

>__Входные данные__  
2 4  
vova  
masha  
+vova => +masha  
+masha => -vova  
-vova => -masha  
-masha => +vova  
__Выходные данные__  
-1

***

<a name="H"></a>
<h1 align="center">H. Авиаперелеты</h1>  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>  
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: avia.in  <br>
вывод: avia.out</i></p>

__Условие:__  
Главного конструктора Петю попросили разработать новую модель самолета для компании «Air Бубундия». Оказалось, что самая сложная часть заключается в подборе оптимального размера топливного бака.

Главный картограф «Air Бубундия» Вася составил подробную карту Бубундии. На этой карте он отметил расход топлива для перелета между каждой парой городов.

Петя хочет сделать размер бака минимально возможным, для которого самолет сможет долететь от любого города в любой другой (возможно, с дозаправками в пути).

__Входные данные:__  
Первая строка входного файла содержит натуральное число n (1 ≤ n ≤ 1000) — число городов в Бубундии.

Далее идут n строк по n чисел каждая. j-ое число в i-ой строке равно расходу топлива при перелете из i-ого города в j-ый. Все числа не меньше нуля и меньше 109. Гарантируется, что для любого i в i-ой строчке i-ое число равно нулю.

__Выходные данные:__  
Первая строка выходного файла должна содержать одно число — оптимальный размер бака.

__Пример__  
>__Входные данные__  
4  
0 10 12 16  
11 0 8 9  
10 13 0 22  
13 10 17 0  
__Выходные данные__  
10

***

<a name="I"></a>
<h1 align="center">I. Остовное дерево</h1>  
<p align="center"><i>ограничение по времени на тест: 4 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие:__  
Даны точки на плоскости, являющиеся вершинами полного графа. Вес ребра равен расстоянию между точками, соответствующими концам этого ребра. Требуется в этом графе найти остовное дерево минимального веса.

__Входные данные:__  
Первая строка входного файла содержит натуральное число n — количество вершин графа (1 ≤ n ≤ 10 000). Каждая из следующих n строк содержит два целых числа xi, yi  — координаты i-й вершины ( - 10 000 ≤ xi, yi ≤ 10 000). Никакие две точки не совпадают.

__Выходные данные:__  
Первая строка выходного файла должна содержать одно вещественное число — вес минимального остовного дерева.

__Пример__  
>__Входные данные__  
2  
0 0  
1 1  
__Выходные данные__  
1.4142135624

***
