+ A [Сравнения подстрок](#A)
+ B [Префикс-функция](#B)
+ C [Z-функция](#C)
+ D [Быстрый поиск подстроки в строке](#D)
+ E [Поиск периода](#E)
+ F [Подстроки-3](#F)
+ G [Множественный поиск](#G)
+ H [Множественный поиск 2](#H)
+ I [Множественный поиск 3](#I)
+ J [Суффиксный массив](#J)
+ K [Количество подстрок](#K)
+ L [Циклические сдвиги](#L)
+ M [Наибольшая общая подстрока](#M)
  
<a name="A"></a>
<h1 align="center">A. Сравнения подстрок</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Дана строка. Нужно уметь отвечать на запросы вида: равны ли подстроки [a..b] и [c..d].

__Входные данные:__  
Сперва строка S (не более 105 строчных латинских букв). Далее число M — количество запросов.

__Выходные данные:__  
M строк. Выведите Yes, если подстроки совпадают, и No иначе.

__Пример__  
>__Входные данные__  
trololo<br>
3<br>
1 7 1 7<br>
3 5 5 7<br>
1 1 1 5<br>
__Выходные данные__  
Yes<br>
Yes<br>
No<br>


***

<a name="B"></a>
<h1 align="center">B. Префикс-функция</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Постройте префикс-функцию для заданной строки s.

__Входные данные:__  
Первая строка входного файла содержит s (1 ≤ |s| ≤ 106). Строка состоит из букв латинского алфавита.

__Выходные данные:__  
Выведите значения префикс-функции строки s для всех индексов 1, 2, ..., |s|.

__Пример__  
>__Входные данные__  
aaaAAA<br>
__Выходные данные__  
0 1 2 0 0 0<br>


***

<a name="C"></a>
<h1 align="center">C. Z-функция</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Постройте Z-функцию для заданной строки s.

__Входные данные:__  
Первая строка входного файла содержит s (1 ≤ |s| ≤ 106). Строка состоит из букв латинского алфавита.

__Выходные данные:__  
Выведите значения Z-функции строки s для индексов 2, 3, ..., |s|.

__Пример__  
>__Входные данные__  
aaaAAA<br>
__Выходные данные__  
 2 1 0 0 0<br>

>__Входные данные__  
abacaba<br>
__Выходные данные__  
 0 1 0 3 0 1<br>


***

<a name="D"></a>
<h1 align="center">D. Быстрый поиск подстроки в строке</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Даны строки p и t. Требуется найти все вхождения строки p в строку t в качестве подстроки.

__Входные данные:__  
Первая строка входного файла содержит p, вторая — t (1 ≤ |p|, |t| ≤ 106). Строки состоят из букв латинского алфавита.

__Выходные данные:__  
В первой строке выведите количество вхождений строки p в строку t. Во второй строке выведите в возрастающем порядке номера символов строки t, с которых начинаются вхождения p. Символы нумеруются с единицы.

__Пример__  
>__Входные данные__  
aba<br>
abaCaba<br>
__Выходные данные__  
2<br>
1 5<br>


***

<a name="E"></a>
<h1 align="center">E. Поиск периода </h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Дана строка s. Требуется найти минимальную по длине строку t, такую что s представима в виде конкатенации одной или нескольких строк t.

__Входные данные:__  
Первая строка входного файла содержит s (1 ≤ |s| ≤ 106). Строка состоит из букв латинского алфавита.

__Выходные данные:__  
Выведите длину искомой строки t.

__Пример__  
>__Входные данные__  
abcabcabc<br>
__Выходные данные__  
3<br>

>__Входные данные__  
abacaba<br>
__Выходные данные__  
7<br>


***

<a name="F"></a>
<h1 align="center">F. Подстроки-3</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: стандартный ввод<br>
вывод: стандартный вывод</i></p>

__Условие:__  
Даны K строк из маленьких латинских букв. Требуется найти их наибольшую общую подстроку.

__Входные данные:__  
В первой строке число K (1 ≤ K ≤ 10). 

__Выходные данные:__  
Наибольшая общая подстрока.

__Пример__  
>__Входные данные__  
3<br>
abacaba<br>
mycabarchive<br>
acabistrue<br>
__Выходные данные__  
cab<br>


***

<a name="G"></a>
<h1 align="center">G. Множественный поиск</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: search4.in<br>
вывод: search4.out</i></p>

__Условие:__  
Дан массив строк si и строка t. Требуется для каждой строки si определить, встречается ли она в t как подстрока.

__Входные данные:__  
Первая строка входного файла содержит целое число n — число элементов в s (1 ≤ n ≤ 106). Следующие n строк содержат по одной строке si. Сумма длин всех строк из s не превосходит 106. Последняя строка входного файла содержит t (1 ≤ t ≤ 106). Все строки состоят из строчных латинских букв.

__Выходные данные:__  
Для каждой строки si выведите «YES», если она встречается в t и «NO» в противном случае. Строки нумеруются в порядке появления во входном файле.

__Пример__  
>__Входные данные__  
3<br>
abc<br>
abcdr<br>
abcde<br>
xabcdef<br>
__Выходные данные__  
YES<br>
NO<br>
YES<br>


***

<a name="H"></a>
<h1 align="center">H. Множественный поиск 2</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 256 мегабайт<br>
ввод: search5.in<br>
вывод: search5.out</i></p>

__Условие:__  
Дан массив строк si и строка t. Требуется для каждой строки si определить, сколько раз она встречается в t как подстрока.

__Входные данные:__  
Первая строка входного файла содержит целое число n — число элементов в s (1 ≤ n ≤ 106). Следующие n строк содержат по одной строке si. Сумма длин всех строк из s не превосходит 106. Последняя строка входного файла содержит t (1 ≤ t ≤ 106). Все строки состоят из строчных латинских букв.

__Выходные данные:__  
Для каждой строки si выведите одно число: сколько раз она встречается в t. Строки нумеруются в порядке появления во входном файле.

__Пример__  
>__Входные данные__  
3<br>
abc<br>
abcdr<br>
abcde<br>
xabcdef<br>
__Выходные данные__  
1<br>
0<br>
1<br>


***

<a name="I"></a>
<h1 align="center">I. Множественный поиск 3</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 512 мегабайт<br>
ввод: search6.in<br>
вывод: search6.out</i></p>

__Условие:__  
Дан массив строк si и строка t. Требуется для каждой строки si найти самое левое и самое правое вхождение в t как подстроки.

__Входные данные:__  
Первая строка входного файла содержит целое число n — число элементов в s (1 ≤ n ≤ 106). Следующие n строк содержат по одной строке si. Сумма длин всех строк из s не превосходит 106. Последняя строка входного файла содержит t (1 ≤ t ≤ 106). Все строки состоят из строчных латинских букв.

__Выходные данные:__  
Для каждой строки si выведите два числа: индексы самой левой и самой правой позиции, в которых она встречается в t. Если строка не встречается в t ни разу, выведите  - 1  - 1. Строки нумеруются в порядке появления во входном файле. Позиции нумеруются с 0.

__Пример__  
>__Входные данные__  
3<br>
ab<br>
bcd<br>
abde<br>
abcdab<br>
__Выходные данные__  
0 4<br>
1 1<br>
-1 -1<br>


***

<a name="J"></a>
<h1 align="center">J. Суффиксный массив</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 512 мегабайт<br>
ввод: array.in<br>
вывод: array.out</i></p>

__Условие:__  
Постройте суффиксный массив для заданной строки s, для каждых двух соседних суффиксов найдите длину максимального общего префикса.

__Входные данные:__  
Первая строка входного файла содержит строку s (1 ≤ |s| ≤ 400 000). Строка состоит из строчных латинских букв.

__Выходные данные:__  
В первой строке выведите |s| различных чисел — номера первых символов суффиксов строки s так, чтобы соответствующие суффиксы были упорядочены в лексикографически возрастающем порядке. Во второй строке выведите |s| - 1 чисел — длины наибольших общих префиксов.

__Пример__  
>__Входные данные__  
ababb<br>
__Выходные данные__  
1 3 5 2 4 <br>
2 0 1 1 <br>


***

<a name="K"></a>
<h1 align="center">K. Количество подстрок</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 512 мегабайт<br>
ввод: count.in<br>
вывод: count.out</i></p>

__Условие:__  
Вычислите количество различных подстрок строки s.

__Входные данные:__  
Единственная строка входного файла содержит строку s (1 ≤ |s| ≤ 400 000). Строка состоит из строчных латинских букв.

__Выходные данные:__  
Выведите одно число — ответ на задачу.

__Пример__  
>__Входные данные__  
ababb<br>
__Выходные данные__  
11<br>


***

<a name="L"></a>
<h1 align="center">L. Циклические сдвиги</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 512 мегабайт<br>
ввод: shifts.in<br>
вывод: shifts.out</i></p>

__Условие:__  
k-м циклическим сдвигом строки S называется строка, полученная перестановкой k первых символов строки S в конец строки.Рассмотрим все различные циклические сдвиги строки S и отсортируем их по возрастанию. Требуется вычислить i-ю строчку этого массива.Например, для строки abacabac существует четыре различных циклических сдвига: нулевой (abacabac), первый (bacabaca), второй (acabacab) и третий (cabacaba). После сортировки по возрастанию получится такой массив: abacabac, acabacab, bacabaca, cabacaba.

__Входные данные:__  
В первой строке входного файла записана строка S, длиной не более 100 000 символов с ASCII-кодами от 32 до 126. Во второй строке содержится единственное целое число k (1 ≤ k ≤ 100 000).

__Выходные данные:__  
В выходной файл выведите k-й по возрастанию циклический сдвиг строки S, или слово IMPOSSIBLE, если такого сдвига не существует.

__Пример__  
>__Входные данные__  
abacabac<br>
4<br>
__Выходные данные__  
cabacaba
>__Входные данные__  
abacabac<br>
5<br>
__Выходные данные__  
IMPOSSIBLE<br>


***

<a name="M"></a>
<h1 align="center">M. Наибольшая общая подстрока</h1>
<p align="center"><i><br>
ограничение по времени на тест: 2 секунды<br>
ограничение по памяти на тест: 512 мегабайт<br>
ввод: common.in<br>
вывод: common.out</i></p>

__Условие:__  
Найдите наибольшую общую подстроку строк s и t.

__Входные данные:__  
Первая строка входного файла содержит строку s, вторая — t (1 ≤ |s|, |t| ≤ 100, 000). Строки состоят из строчных латинских букв.

__Выходные данные:__  
Выведите одну строку — наибольшую общую подстроку строк s и t. В случае, если ответ не единственный, выведите минимальный лексикографически.

__Пример__  
>__Входные данные__  
bababb<br>
zabacabba<br>
__Выходные данные__  
aba<br>


***
