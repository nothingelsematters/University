# Деревья поиска

## Задача A. Простое двоичное дерево поиска

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 512 мегабайт
```

Реализуйте просто двоичное дерево поиска.

### Формат входных данных

Входной файл содержит описание операций с деревом, их количество не превышает 100. В каждой строке находится одна из следующих операций:

* `insert x` — добавить в дерево ключ `x`. Если ключxесть в дереве, то ничего делать не надо
* `delete x` — удалить из дерева ключ `x`. Если ключа `x` в дереве нет, то ничего делать не надо
* `exists x` — если ключ `x` есть в дереве выведите «`true`», если нет «`false`»
* `next x` — выведите минимальный элемент в дереве, строго больший `x`, или «`none`» если такого нет
* `prev x` — выведите максимальный элемент в дереве, строго меньшийx, или «none» если такого нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 109.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций exists, next, prev. Следуйте формату выходного файла из примера.

### Пример


#### стандартный ввод

```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

#### стандартный вывод

```
true
false
5
3
none
3
```

## Задача B. Сбалансированное двоичное дерево поиска

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 512 мегабайт
```

Реализуйте сбалансированное двоичное дерево поиска.

### Формат входных данных

Входной файл содержит описание операций с деревом, их количество не превышает 105. В каждой строке находится одна из следующих операций:

* `insert x` — добавить в дерево ключ `x`. Если ключxесть в дереве, то ничего делать не надо
* `delete x` — удалить из дерева ключ `x`. Если ключа `x` в дереве нет, то ничего делать не надо
* `exists x` — если ключ `x` есть в дереве выведите «`true`», если нет «`false`»
* `next x` — выведите минимальный элемент в дереве, строго больший `x`, или «`none`» если такого нет
* `prev x` — выведите максимальный элемент в дереве, строго меньшийx, или «none» если такого нет
*
В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 109.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций exists, next, prev. Следуйте формату выходного файла из примера.

### Пример


#### стандартный ввод
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

#### стандартный вывод

```
true
false
5
3
none
3
```

## Задача C. Декартово дерево

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
```

Вам даны пары чисел (a<sub>i</sub>, b<sub>i</sub>). Необходимо построить декартово дерево, такое что i-я вершина имеет ключи (a<sub>i</sub>, b<sub>i</sub>), вершины с ключом a<sub>i</sub> образуют бинарное дерево поиска, а вершины с ключом b<sub>i</sub> образуют кучу.

### Формат входных данных

В первой строке записано число N — количество пар. Далее следует N (1 ⩽ N ⩽ 300 000) пар (a<sub>i</sub>, b<sub>i</sub>). Для всех пар |a<sub>i</sub>|, |b<sub>i</sub>| ⩽ 30 000. a<sub>i</sub> <= a<sub>j</sub> и b<sub>i</sub> <= b<sub>j</sub> для всех i <= j.

### Формат выходных данных

Если декартово дерево с таким набором ключей построить возможно, выведите в первой строке «`YES`», в противном случае выведите «`NO`». В случае ответа «`YES`» выведите N строк, каждая из которых должна описывать вершину. Описание вершины состоит из трёх чисел: номера предка, номера левого сына и номера правого сына. Если у вершины отсутствует предок или какой либо из сыновей, выведите на его месте число 0. Если подходящих деревьев несколько, выведите любое.

### Пример

#### стандартный ввод
```
7
5 4
2 2
3 9
0 5
1 3
6 6
4 11
```

#### стандартный вывод
```
YES
2 3 6
0 5 1
1 0 7
5 0 0
2 4 0
1 0 0
3 0 0
```

## Задача D. Добавление ключей

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
```

Вы работаете в компании Макрохард и вас попросили реализовать структуру данных, которая будет хранить множество целых ключей.

Будем считать, что ключи хранятся в бесконечном массиве A, проиндексированном с 1, исходно все его ячейки пусты. Структура данных должна поддерживать следующую операцию:

`Insert(L, K)`, где L — позиция в массиве, а K— некоторое положительное целое число.

Операция должна выполняться следующим образом:

* Если ячейка A[L] пуста, присвоить A[L] <- K.
* Если A[L] непуста, выполнить `Insert(L + 1, A[L])` и затем присвоить A[L] <- K.

По заданным N целым числам выведите массив после выполнения последовательности операций:
```
Insert(L 1, 1)
Insert(L 2, 2)
...
Insert(L N, N)
```

### Формат входных данных

Первая строка входного файла содержит числа N — количество операций `Insert`, которое следует выполнить и M — максимальную позицию, которая используется в операциях `Insert` (1 ⩽ N ⩽ 131 072, 1 ⩽ M ⩽131 072).

Следующая строка содержит N целых чисел L<sub>i</sub>, которые описывают операции Insert, которые следует выполнить (1 ⩽ L<sub>i</sub> ⩽ M).

### Формат выходных данных

Выведите содержимое массива после выполнения всех сделанных операций Insert. На первой строке выведите W — номер максимальной непустой ячейки в массиве. Затем выведите W целых чисел. Выводите нули для пустых ячеек.

### Пример

#### стандартный ввод
```
5 4
3 3 4 1 3
```

#### стандартный вывод
```
6
4 0 5 2 3 1
```

## Задача E. И снова сумма

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 3 секунды
Ограничение по памяти: 256 мегабайт
```

Реализуйте структуру данных, которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:

* `add(i)`— добавить в множество S число i (если он там уже есть, то множество не меняется);
* `sum(l, r)` — вывести сумму всех элементов x из S, которые удовлетворяют неравенству l ⩽ x ⩽ r.

### Формат входных данных

Исходно множество S пусто. Первая строка входного файла содержит n — количество операций (1 ⩽ n ⩽ 300 000). Следующие n строк содержат операции. Каждая операция имеет вид либо «`+i`», либо «`? l r`». Операция «`? l r`» задает запрос `sum(l, r)`.

Если операция «`+i`» идет во входном файле в начале или после другой операции «`+`», то она задает операцию `add(i)`. Если же она идет после запроса «`?`», и результат этого запроса былy, то
выполняется операция `add((i + y) mod 10^9)`.

Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 109.

### Формат выходных данных

Для каждого запроса выведите одно число — ответ на запрос.

### Пример

#### стандартный ввод
```
6
+ 1
+ 3
+ 3
? 2 4
+ 1
? 2 4
```

#### стандартный вывод
```
3
7
```

## Задача F. K-й максимум

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 512 мегабайт
```

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить k-й максимум.

### Формат входных данных

Первая строка входного файла содержит натуральное число n — количество команд (n ⩽ 100 000). Последующие n строк содержат по одной команде каждая. Команда записывается в виде двух чиселc i и k<sub>i</sub> — тип и аргумент команды соответственно (|k<sub>i</sub>| ⩽ 109).

Поддерживаемые команды:

* `+1` (или просто `1`): Добавить элемент с ключом k<sub>i</sub>.
* `0` : Найти и вывести k<sub>i</sub>-й максимум.
* `-1` : Удалить элемент с ключом k<sub>i</sub>.

Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными ключами или удалять несуществующие элементы. Также гарантируется, что при запросе k<sub>i</sub>-го максимума, он существует.

### Формат выходных данных

Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержащая единственное число — k<sub>i</sub>-й максимум.

### Пример

#### стандартный ввод
```
11
+1 5
+1 3
+1 7
0 1
0 2
0 3
-1 5
+1 10
0 1
0 2
0 3
```

#### стандартный вывод
```
7
5
3
10
7
3
```

## Задача G. Переместить в начало

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 6 секунд
Ограничение по памяти: 512 мегабайт
```

Вам дан массив `a` и последовальность операций: переместить элементы в начало массива. Например, для массива `[2, 3, 6, 1, 5, 4]`, после операции `(2, 4)` новый порядок будет `[3, 6, 1, 2, 5, 4]`. А после применения операции `(3, 4)` порядок элементов в массиве будет `[1, 2, 3, 6, 5, 4]`.

Выведите порядок элементов в массиве после выполнения всех операций.

### Формат входных данных

В первой строке входного файла указаны числа n и m (2 ⩽ n ⩽ 100 000, 1 ⩽ m ⩽ 100 000) — число элементов в массиве и число операций.

Следующие m строк содержат операции в виде двух целых чисел: l<sub>i</sub> и r<sub>i</sub> (1 ⩽ l<sub>i</sub> ⩽ r<sub>i</sub> ⩽ n).

### Формат выходных данных

Выведитеnцелых чисел — порядок элементов в массиве после применения всех операций.

### Пример

#### стандартный ввод
```
6 3
2 4
3 5
2 2
```

#### стандартный вывод
```
1 4 5 2 3 6
```

## Задача H. Различные буквы

```
Имя входного файла: log.in
Имя выходного файла: log.out
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
```

Вы работаете со списком из строчных латинских букв. Изначально список пуст. Вы должны поддерживать следующие операции:

* `insert ⟨index⟩ ⟨number⟩ ⟨letter⟩` - добавить `⟨number⟩` букв `⟨letter⟩` перед буквой с индексом `⟨index⟩`.
* `remove ⟨index⟩ ⟨number⟩` — удалить `⟨number⟩` букв, начиная с индекса `⟨index⟩`.
* `query ⟨index 1⟩ ⟨index  ⟩` — вывести количество различных букв на отрезке с `⟨index 1⟩` до `⟨index 2⟩` включительно.

Буквы нумеруются с 1.

### Формат входных данных

В первой строке входного файла содержится единственное целое число n — количество операций (1 ⩽ n ⩽ 30 000). Следующие поnстрок содержат описание операций.

Описание операции начинается с типа операции: '`+`' для добавления, '`-`' для удаления и '`?`' для запроса. Дальше следует аргументы запроса, описанные в условиях выше.

Все запросы корректны, элементы с такими индексами существуют, нет запросов на удаление несуществующих элементов.

`⟨number⟩` добавления, удаления не превышает 10 000.

### Формат выходных данных

Для каждого запроса `query` выведите одно целое число — количество различных букв на отрезке `⟨index 1⟩, ⟨index 2⟩` включительно.

### Пример

#### log.in
```
8
+ 1 4 w
+ 3 3 o
? 2 3
- 2 2
? 2 3
+ 2 2 t
? 1 6
- 1 6
```

#### log.out
```
2
1
3
```

> Замечание
> Пояснение к примеру:
> 1. `wwww`
> 2. `wwoooww`
> 3. `w[wo]ooww`: 2 различные буквы
> 4. `wooww`
> 5. `w[oo]ww`: 1 буква
> 6. `wttooww`
> 7. `[wttoow]w`: 3 различные буквы
> 8. `w`

## Задача I. Эх, дороги

```
Имя входного файла: roads.in
Имя выходного файла: roads.out
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
```

В многострадальном Тридесятом государстве опять готовится дорожная реформа. Впрочем, надо признать, дороги в этом государстве находятся в довольно плачевном состоянии. Так что реформа не повредит. Одна проблема — дорожникам не развернуться, поскольку в стране действует жесткий закон — из каждого города должно вести не более двух дорог. Все дороги в государстве двусторонние, то есть по ним разрешено движение в обоих направлениях (разумеется, разметка отсутствует). В результате реформы некоторые дороги будут строиться, а некоторые другие закрываться на бессрочный ремонт.

Петя работает диспетчером в службе грузоперевозок на дальние расстояния. В связи с предстоящими реформами, ему необходимо оперативно определять оптимальные маршруты между городами в условиях постоянно меняющейся дорожной ситуации. В силу большого количества пробок и сотрудников дорожной полиции в городах, критерием оптимальности маршрута считается количество промежуточных городов, которые необходимо проехать.

Помогите Пете по заданной последовательности сообщений об изменении структуры дорог и запросам об оптимальном способе проезда из одного города в другой, оперативно отвечать на запросы.

### Формат входных данных

В первой строке входного файла заданы числа n — количество городов, m — количество дорог в начале реформы и q — количество сообщений об изменении дорожной структуры и запросов (1 ⩽ n, m ⩽ 100 000, q ⩽200 000). Следующие m строк содержат по два целых числа каждая — пары
городов, соединенных дорогами перед реформой. Следующиеqстрок содержат по три элемента, разделенных пробелами. «`+ i j`» означает строительство дороги от городаiдо городаj, «`- i j`» означает закрытие дороги от города i до города j, «`? i j`» означает запрос об оптимальном пути между городами i и j.

Гарантируется, что в начале и после каждого изменения никакие два города не соединены более чем одной дорогой, и из каждого города выходит не более двух дорог. Никакой город не соединяется дорогой сам с собой.

### Формат выходных данных

На каждый запрос вида «`? i j`» выведите одно число — минимальное количество промежуточных городов на маршруте из города i в город j. Если проехать из i в j невозможно, выведите 1.

### Пример

#### roads.in
```
5 4 6
1 2
2 3
1 3
4 5
? 1 2
? 1 5
- 2 3
? 2 3
+ 2 4
? 1 5
```

#### roads.out
```
0
-
1
2
```
