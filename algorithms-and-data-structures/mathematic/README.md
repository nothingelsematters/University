# Математика

## [A. Массовая проверка простоты](a_multiple_primality_test.cpp)

```
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
ввод стандартный ввод
вывод стандартный вывод
```

Целое число p ≥ 2 является простым, если у него нет делителей кроме 1 и p. Необходимо для всех чисел во входном файле проверить простые они или нет.

## Входные данные

В первой строке задано число n (2 ≤ n ≤ 300000). В следующих n строках заданы числа a<sub>i</sub> (2 ≤ a<sub>i</sub> ≤ 10<sup>6</sup>), которые нужно проверить на простоту

## Выходные данные

Для каждого числа во входном файле выведите на отдельной строке YES или NO (в зависимости от того, простое оно или нет).

## Пример

### Входные данные
```
4
60
14
3
55
```

### Выходные данные
```
NO
NO
YES
NO
```

## [B. Массовое разложение на множители](b_multiple_factorization.cpp)
```
ограничение по времени на тест 0.5 секунд
ограничение по памяти на тест 64 мегабайта
ввод стандартный ввод
вывод стандартный вывод
```

Дано много чисел. Требуется разложить их все на простые множители.

## Входные данные

В первой строке задано число n (2 ≤ n ≤ 300000). В следующих n строках заданы числа a<sub>i</sub> (2 ≤ a<sub>i</sub> ≤ 106), которые нужно разложить на множители.

### Выходные данные

Для каждого числа выведите в отдельной строке разложение на простые множители в порядке возрастания множителей.

## Пример

### Входные данные
```
4
60
14
3
55
```

## Выходные данные
```
2 2 3 5
2 7
3
5 11
```

## [C. Большая проверка на простоту](c_big_primality_test.cpp)

```
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 64 мегабайта
ввод стандартный ввод
вывод стандартный вывод
```

Дано n натуральных чисел a<sub>i</sub>. Определите для каждого числа, является ли оно простым.

## Входные данные

Программа получает на вход число n, 1 ≤ n ≤ 1000 и далее n чисел a<sub>i</sub>, 1 ≤ a<sub>i</sub> ≤ 10<sup>18</sup>.

## Выходные данные

Если число a<sub>i</sub> простое, программа должна вывести YES, для составного числа программа должна вывести NO.

## Пример

### Входные данные
```
4
1
5
10
239
```

### Выходные данные
```
NO
YES
NO
YES
```

## [D. Китайская теорема](d_chinese_theorem.cpp)
```
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 64 мегабайта
ввод стандартный ввод
вывод стандартный вывод
```

Решите в целых числах систему уравнений

```
x = a (mod n),
x = b (mod m)
```

где n и m - взаимно простые числа. Среди решений выбрать наименьшее неотрицательное число.

## Формат входных данных

Входной файл содержит четыре целых числа a, b, n и m (1 ≤ n, m ≤ 10<sup>6</sup>, 0 ≤ a < n, 0 ≤ b < m).

## Формат выходных данных

В выходной файл выведите искомое наименьшее неотрицательное число x.

## Примеры

### стандартный ввод
```
1 0 2 3
```

### стандартный вывод
```
3
```

---

### стандартный ввод
```
3 2 5 9
```

### стандартный вывод
```
38
```

## [E. Взлом RSA](e_hack_rsa.cpp)
```
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 64 мегабайта
ввод стандартный ввод
вывод стандартный вывод
```

В 1977 году Ronald Linn Rivest, Adi Shamir и Leonard Adleman предложили новую криптографическую схему RSA, используемую до сих пор. RSA является криптосистемой с открытым ключом: зашифровать сообщение может кто угодно, знающий общеизвестный открытый ключ, а расшифровать сообщение — только тот, кто знает специальный секретный ключ.

Желающий использовать систему RSA для получения сообщений должен сгенерировать два простых числа p и q, вычислить n = pq и сгенерировать два числа e и d такие, что {ed ≡ 1 ± od{(p - 1)(q - 1)}} (заметим, что {(p - 1)(q - 1) = φ(n)}). Числа n и e составляют открытый ключ и являются общеизвестными. Число d является секретным ключом, также необходимо хранить в тайне и разложение числа n на простые множители, так как это позволяет вычислить секретный ключ d.

Сообщениями в системе RSA являются числа из Z<sub>n</sub>. Пусть M — исходное сообщение. Для его шифрования вычисляется значение C = M<sup>e</sup> mod n (для этого необходимо только знание открытого ключа). Полученное зашифрованное сообщение C передается по каналу связи. Для его расшифровки необходимо вычислить значение M = C<sup>d</sup> mod n, а для этого необходимо знание секретного ключа.

Вы перехватили зашифрованное сообщение C и знаете только открытый ключ: числа n и e. "Взломайте" RSA — расшифруйте сообщение на основе только этих данных.

## Входные данные

Программа получает на вход три натуральных числа: n, e, C, n ≤ 10<sup>9</sup>, e ≤ 10<sup>9</sup>, C < n. Числа n и e являются частью какой-то реальной схемы RSA, т.е. n является произведением двух простых и e взаимно просто с φ(n). Число C является результатом шифрования некоторого сообщения M.

## Выходные данные

Выведите одно число M (0 ≤ M < n), которое было зашифровано такой криптосхемой.

## Примеры

### Входные данные
```
143
113
41
```

### Выходные данные
```
123
```

---

### Входные данные
```
9173503
3
4051753
```

## Выходные данные
```
111111
```

## [F. Задача для второклассника](f_multiplication.cpp)

```
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
ввод стандартный ввод
вывод стандартный вывод
```

Вам даны два числа. Необходимо найти их произведение.

## Входные данные

Входные данные состоят из двух строк, на каждой из которых находится целое одно целое число, длина которого не превосходит двухсот пятидесяти тысяч символов.

## Выходные данные

Выведите произведение данных чисел.

## Примеры

### Входные данные
```
2
2
```

### Выходные данные
```
4
```

---

### Входные данные
```
1
-1
```

### Выходные данные
```
-1
```
