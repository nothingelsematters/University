# Type theory

## [Задача 1. Расстановка скобок в лямбда-выражении](1-lambda-expression-parsing)

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 5 секунды
Ограничение по памяти: 512 мегабайт
```

На вход вашей программе дается лямбда-выражение в следующей грамматике:


```haskell
⟨Выражение⟩ ::= [⟨Применение⟩] \ ⟨Переменная⟩ . ⟨Выражение⟩
⟨Применение⟩ ::= ⟨Применение⟩ ⟨Атом⟩ | ⟨Атом⟩
⟨Атом⟩ ::= ( ⟨Выражение⟩ ) | ⟨Переменная⟩
⟨Переменная⟩ ::= (a-z) {a-z, 0-9, '}*
```

Аргументы-переменные в применении должны разделяться пробелом. В остальных случаях пробелы могут отсутствовать. Любые пробелы между нетерминальными символами (кроме пробела,
разделяющего аргументы в применении) — а также начальные и конечные пробелы в строке —
должны игнорироваться. Символы табуляции, возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется расставить все недостающие скобки вокруг всех абстракций и применений, и напечатать получившийся результат.

### Формат входных данных

Размер входного файла не превышает 1 МБ.

### Формат выходных данных

В единственной строке выходного файла (заканчивающейся переводом строки) должно быть
приведено лямбда-выражение с расставленными скобками без каких-либо пробельных символов.
Исключение: одиночные пробелы, разделяющие аргументы в применении.

### Примеры

| стандартный ввод |
| --- |
| `\a.\b.a b c (\d.e \f.g) h` |
| стандартный вывод |
| `(\a.(\b.((((a b) c) (\d.(e (\f.g)))) h)))` |

| стандартный ввод |
| --- |
| `((a\bbb.c)d)e` <br> `f g` |
| стандартный вывод |
| `(((((a (\bbb.c)) d) e) f) g)` |

## [Задача 3. Вывод типа в просто-типизированном лямбда-исчислении](3-type-deduction)

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 10 секунды
Ограничение по памяти: 512 мегабайт
```

На вход вашей программе дается лямбда-выражение в следующей грамматике:

```haskell
⟨Выражение⟩ ::= [⟨Применение⟩] \ ⟨Переменная⟩ . ⟨Выражение⟩
⟨Применение⟩ ::= ⟨Применение⟩ ⟨Атом⟩ | ⟨Атом⟩
⟨Атом⟩ ::= ( ⟨Выражение⟩ ) | ⟨Переменная⟩
⟨Переменная⟩ ::= (a-z) {a-z, 0-9, '}*
```

Аргументы-переменные в применении разделяются пробелом. В остальных случаях пробелы могут отсутствовать. Любые пробелы между нетерминальными символами (кроме пробела, разделяющего аргументы в применении) — а также начальные и конечные пробелы в строке — должны игнорироваться. Символы табуляции и возврата каретки должны трактоваться как пробелы.

Требуется найти наиболее общий тип этого лямбда-выражения и вывести доказательство того, что лямбда-выражение имеет этот тип, а также найти типы свободных переменных, содержащихся в лямбда-выражении, или же сказать, что лямбда-выражение не имеет типа.

В доказательстве вы можете пользоваться следующими правилами:

### Формат входных данных

В единственной строке входного файла содержится лямбда-выражение в грамматике из условия. Длина выражения не превышает 255 символов.

Гарантируется, что имена всех вложенных абстракций различны, а также имена абстракций не совпадают с именами свободных переменных.

### Формат выходных данных
Если заданное лямбда-выражение не имеет типа, в единственной строке выходного файла должна быть запись «`Expression has no type`».

Иначе в файле должно быть доказательство. В файле должны отсутствовать пустые строки.
Строки доказательства должны идти в правильном порядке. Каждый отступ должен представляться с помощью «\*» — символа «\*» (ASCII 42) и трех последовательных пробелов (ACSII 32). В конце каждой строки должно быть описание правила, которое было применено для вывода этой строки. В остальном следуйте формату из примеров.

Выведенный тип должен быть наиболее общим типом для заданного лямбда-выражения.

### Примеры

| стандартный ввод |
| :--- |
| `x` |
| стандартный вывод |
| `x : t1 |- x : t1 [rule #1]` |
| стандартный ввод |
| `(\x. x) (\y. y)` |
| стандартный вывод |
| `|- ((\x.x) (\y.y)) : (t3 -> t3) [rule #2]` </br> `*   |- (\x.x) : ((t3 -> t3) -> (t3 -> t3)) [rule #3]` </br> `*   *   x : (t3 -> t3) |- x : (t3 -> t3) [rule #1]` </br> `*   |- (\y.y) : (t3 -> t3) [rule #3]` </br> `*   *   y : t3 |- y : t3 [rule #1]` |
| стандартный ввод |
| `\a. a' a z8'` |
| стандартный вывод |
| `z8' : t4, a' : (t1 -> (t4 -> t5)) |- (\a.((a' a) z8')) : (t1 -> t5) [rule #3]` </br> `*   z8' : t4, a' : (t1 -> (t4 -> t5)), a : t1 |- ((a' a) z8') : t5 [rule #2]` </br> `*   *   z8' : t4, a' : (t1 -> (t4 -> t5)), a : t1 |- (a' a) : (t4 -> t5) [rule #2]` </br> `*   *   *   z8' : t4, a' : (t1 -> (t4 -> t5)), a : t1 |- a' : (t1 -> (t4 -> t5)) [rule #1]` </br> `*   *   *   z8' : t4, a' : (t1 -> (t4 -> t5)), a : t1 |- a : t1 [rule #1]` </br> `*   *   z8' : t4, a' : (t1 -> (t4 -> t5)), a : t1 |- z8' : t4 [rule #1]` |
