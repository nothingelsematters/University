# Mathematical Logic


## [Задача 1. Разбор утверждения](1-expression-parser)

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
```

На вход вашей программе дается утверждение в следующей грамматике:


```haskell
⟨Файл⟩ ::= ⟨Выражение⟩
⟨Выражение⟩ ::= ⟨Дизъюнкция⟩|⟨Дизъюнкция⟩->⟨Выражение⟩
⟨Дизъюнкция⟩ ::= ⟨Конъюнкция⟩|⟨Дизъюнкция⟩|⟨Конъюнкция⟩
⟨Конъюнкция⟩ ::= ⟨Отрицание⟩|⟨Конъюнкция⟩&⟨Отрицание⟩
⟨Отрицание⟩ ::= !⟨Отрицание⟩|⟨Переменная⟩| (⟨Выражение⟩)
⟨Переменная⟩ ::= (A-Z) {A-Z, 0-9, '} 
```

Имена переменных не содержат пробелов. Между символами оператора `->` нет пробелов. В
остальных местах пробелы могут присутствовать. Символы табуляции и возврата каретки должны
трактоваться как пробелы.
Вам требуется написать программу, разбирающую утверждение и строящую его дерево разбора,
и выводящую полученное дерево в единственной строке без пробелов в следующей грамматике:


```haskell
⟨Файл⟩ ::= ⟨Вершина⟩
⟨Вершина⟩ ::= (⟨Знак⟩,⟨Вершина⟩,⟨Вершина⟩)
            | (!⟨Вершина⟩)
            | ⟨Переменная⟩
⟨Знак⟩ ::= ->, |, &
⟨Переменная⟩ ::= (A-Z) {A-Z, 0-9, '}
```

### Формат входных данных

В единственной строке входного файла дано утверждение в грамматике из условия. Размер
входного файла не превышает 100 КБ.

### Формат выходных данных

В единственной строке выходного файла выведите дерево разбора утверждения без пробелов.

### Примеры

стандартный ввод

```haskell
!A&!B->!(A|B)
```

стандартный вывод

```haskell
(->,(&,(!A),(!B)),(!(|,A,B)))
```

---

стандартный ввод

```haskell
P1'->!QQ->!R10&S|!T&U&V
```

стандартный вывод

```haskell
(->,P1',(->,(!QQ),(|,(&,(!R10),S),(&,(&,(!T),U),V))))
```

---

## [Задача 2. Минимизация доказательства](2-proof-minimization)

```
Имя входного файла: стандартный ввод
Имя выходного файла: стандартный вывод
Ограничение по времени: 15 секунд
Ограничение по памяти: 512 мегабайт
```

На вход вашей программе дается доказательство утверждения в следующей грамматике:

```haskell
⟨Файл⟩ ::= ⟨Контекст⟩ |- ⟨Выражение⟩ \n ⟨Строка⟩*
⟨Контекст⟩ ::= ⟨Выражение⟩ [,⟨Выражение⟩]*
⟨Строка⟩ ::= ⟨Выражение⟩\n
⟨Выражение⟩ ::= ⟨Выражение⟩&⟨Выражение⟩
              | ⟨Выражение⟩|⟨Выражение⟩
              | ⟨Выражение⟩->⟨Выражение⟩
              | !⟨Выражение⟩
              | (⟨Выражение⟩)
              | ⟨Переменная⟩
⟨Переменная⟩ ::= (A-Z) {A-Z, 0-9, '}
```

Операторы `&` и `|` левоассоциативны. Оператор `->` правоассоциативен.
Операторы в порядке уменьшения приоритета: `!`, `&`, `|`, `->`.
Имена переменных не содержат пробелов. Между символами одного оператора нет пробелов (`->` и `|-`).
 В остальных местах пробелы могут присутствовать. Символы табуляции и возврата
каретки должны трактоваться как пробелы.
Требуется проверить доказательство на корректность. Если оно неверно, выведите `«Proof is
incorrect»`. Иначе минимизируйте и проаннотируйте доказательство.
Под минимизацией доказательства подразумевается создание нового доказательства такого, что:

+ Новое доказательство доказывает то же самое утверждение в том же самом контексте

+ Строки нового доказательства являются подпоследовательностью строк исходного доказатель-
ства

+ В новом доказательстве ни одно выражение не встречается в нескольких строках

+ В новом доказательстве нет неиспользуемых выражений, т.е. все выражения, кроме последне-
го, должны использоваться одним или более применением правила Modus Ponens.

Под аннотированием доказательства подразумевается:

+ Все строки должны быть пронумерованы

+ Каждая строка должна содержать пояснение, как она была выведена:

```
    Аксиома: номер аксиомы
    Предположение: номер предположения
    Modus Ponens: номера строк, в которых записаны выражения, используемые для вывода
    выражения в текущей строке
```

### Формат входных данных

Во входном файле задано доказательство в приведенной выше грамматике. Размер входного
файла не превышает 10 МБ.

### Формат выходных данных

Если данное доказательство является некорректным, в единственной строке выходного файла
должна быть запись `«Proof is incorrect»`.
Иначе в файле должно быть минимизированное проаннотированое корректное доказательство.
Каждая строка, кроме последней, должна быть использована хотя бы в одной аннотации Modus
Ponens. Подробный формат аннотаций смотрите в примерах.


### Примеры

стандартный ввод
```haskell
|- A -> A
A & A -> A
A -> A -> A
A -> (A -> A) -> A
A & A -> A
(A -> A -> A) -> (A -> (A -> A) -> A) -> A -> A
(A -> (A -> A) -> A) -> A -> A
A & A -> A
A -> A
```

стандартный вывод
```haskell
|- (A -> A)
[1. Ax. sch. 1] (A -> (A -> A))
[2. Ax. sch. 1] (A -> ((A -> A) -> A))
[3. Ax. sch. 2] ((A -> (A -> A)) -> ((A -> ((A -> A) -> A)) -> (A -> A)))
[4. M.P. 3, 1] ((A -> ((A -> A) -> A)) -> (A -> A))
[5. M.P. 4, 2] (A -> A)
```

---

стандартный ввод
```haskell
A->B, !B |- !A
A->B
!B
!B -> A -> !B
A -> !B
(A -> B) -> (A -> !B) -> !A
(A -> !B) -> !A
!A
```

стандартный вывод
```haskell
(A -> B), !B |- !A
[1. Hypothesis 1] (A -> B)
[2. Hypothesis 2] !B
[3. Ax. sch. 1] (!B -> (A -> !B))
[4. M.P. 3, 2] (A -> !B)
[5. Ax. sch. 9] ((A -> B) -> ((A -> !B) -> !A))
[6. M.P. 5, 1] ((A -> !B) -> !A)
[7. M.P. 6, 4] !A
```

---

стандартный ввод
```haskell
A, C |- B'
B'
```
стандартный вывод

`Proof is incorrect`
